### 排序

```
选择排序
冒泡排序
插入排序
快速排序
归并排序
希尔排序
堆排序
计数排序
桶排序
基数排序
```

### 查找

```
二分查找
Java中的排序工具
```

```
常用算法
KPM 算法
排序、查找算法
布隆过滤器
字符串比较
深度优先、广度优先
贪心算法
回溯算法
剪枝算法
动态规划
朴素贝叶斯
推荐算法
最小生成树算法
最短路径算法
```

```
1、排序都有哪几种方法？
2、会写常用的排序算法，如快排，归并等。
3、各种排序算法的时间复杂度和 稳定性 ，重点快排。
4、单链表的遍历和逆序 
5、深度优先搜索和 广度优先搜索
6、最小生成树
7、常见Hash算法，哈希的原理和代价
8、全排列、贪心算法、KMP算法、hash算法
9、一致性Hash算法
```

第一章 - 算法基础 

1.1 算法复杂度计算

1.2 神奇的兔子数列

第二章 - 线性表

2.1 链表

2.2 链表实例

第三章 - 栈与队列

3.1 栈

3.2 队列

第四章 - 数组

4.1 数组

4.2 特殊矩阵的压缩存储

第五章 - 字符串

5.1 字符串

5.2 KMP算法

第六章 - 二叉树 

6.1 二叉树存储

6.2 二叉树遍历

第七章 - 树+贪心 

7.1 哈夫曼树

7.2 哈夫曼编码

第八章 - 图的存储

8.1 邻接矩阵

8.2 邻接表

第九章 - 图搜索

9.1 深度优先搜索

9.2 广度优先搜索

第十章 - 图的连通性

10.1 连通分量

10.2 Tarjan算法

第一十一章 - 图+贪心

11.1 最短路径

11.2 Dijkstra、Floyd算法

11.3 最小生成树

11.4 Prim、Kruskal算法

第一十二章 - 图的应用 

12.1 拓扑排序（一）

12.2 拓扑排序（二）

12.3 关键路径（一）

12.4 关键路径（二）

第一十三章 - 查找+分治 

13.1 折半查找

13.2 哈希表

第一十四章 - 数表查找 

14.1 二叉搜索树（一）

14.2 二叉搜索树（二）

14.3 平衡二叉树（一）

14.4 平衡二叉树（二）

第一十五章 - 简单排序 

15.1 插入排序

15.2 冒泡排序

第一十六章 - 排序+分治 

16.1 快速排序

16.2 归并排序

第一十七章 - 树形排序 

17.1 选择排序

17.2 堆排序

第一十八章 - 分配排序 

18.1 桶排序

18.2 基数排序

第一十九章 - 高级数据结构 

19.1 并查集（一）

19.2 并查集（二）

19.3 优先队列（一）

19.4 优先队列（二）

19.5 树状数组（一）

19.6 树状数组（二）

19.7 线段树（一）

19.8 线段树（二）

19.9 倍增、ST表、RMQ（一）

19.10 倍增、ST表、RMQ（二）

19.11 LCA（一）

19.12 LCA（二）

19.13 Treap树（一）

19.14 Treap树（二）

19.15 树链剖分（一）

19.16 树链剖分（二）

19.17 字典树（一）

19.18 字典树（二）

19.19 后缀数组（一）

19.20 后缀数组（二）

19.21 分块（一）

19.22 分块（二）

19.23 点分治（一）

19.24 点分治（二）

19.25 边分治（一）

19.26 边分治（二）

19.27 AC自动机（一）

19.28 AC自动机（二）

19.29 B-树（一）

19.30 B-树（二）

19.31 B-树（三）

19.32 B-树（四）

19.33 红黑树（一）

19.34 红黑树（二）

19.35 红黑树（三）

19.36 红黑树（四）

19.37 伸展树Splay（一）

19.38 伸展树Splay（二）

19.39 K-D树（一）

19.40 K-D树（二）

19.41 动态树（一）

19.42 动态树（二）

19.43 左偏树（可合并堆）（一）

19.44 左偏树（可合并堆）（二）

19.45 SBT树（一）

19.46 SBT树（二）

19.47 跳表（一）

19.48 跳表（二）

19.49 树套树（一）

19.50 树套树（二）

19.51 可持久化数据结构（一）

19.52 可持久化数据结构（二）

第二十章 - 贪心+动态规划 

20.1 背包问题

20.2 01背包问题

第二十一章 - 动态规划 

21.1 线性DP

21.2 最长公共子序列、最长上升子序列

21.3 树形DP

21.4 背包类树形DP

21.5 区间DP

21.6 矩阵连乘、石子合并

21.7 数位DP

21.8 数字游戏

21.9 状态压缩DP

21.10 旅行商

21.11 插头DP

第二十二章 - 动态规划优化 

22.1 倍增优化

22.2 数据结构优化

22.3 单调队列优化

22.4 斜率优化

22.5 四边不等式优化

第二十三章 - 深度搜索应用 

23.1 回溯法

23.2 01背包

23.3 地图着色

23.4 n皇后

23.5 最优加工顺序

第二十四章 - 广度搜索应用 

24.1 01背包

24.2 旅行商问题

第二十五章 - 启发式搜索

25.1 A*搜索（一）

25.2 A*搜索（二）

第二十六章 - 最大流

26.1 最短增广路算法

26.2 Dinic算法

第二十七章 - 最大流改进算法

27.1 标签算法ISPA（一）

27.2 标签算法ISPA（二）

第二十八章 - 二分图最大匹配

28.1 配对方案

28.2 匈牙利算法

第二十九章 - 最大流最小割 

29.1 最大收益

29.2 方格取数

第三十章 - 最小费用最大流

30.1 最小费用路算法

30.2 消圈算法

### 树

#### 二叉树

* `在二叉树的第i层上最多有2 i-1 个节点 。（i>=1）`
* `二叉树中如果深度为k(有k层),那么最多有2k-1个节点。(k>=1）`
* `若二叉树按照从上到下从左到右依次编号，则若某节点编号为k，则其左右子树根节点编号分别为2k和2k+1`

##### 二叉树分类：满二叉树，完全二叉树

* `一棵树里最远的两个节点间的距离`
* `实现一个二叉树的持久化方案 `
* `二叉树层级遍历，以及follow up是每下一层遍历方向颠倒 `
* `一棵树里最远的两个节点间的距离 `
* `二叉树最小公共祖先`

##### 深度优先算法(DFS)和广度优先算法(BFS)

##### 二叉树的三种访问方式(深度优先) 

* `先序遍历：按照根节点->左子树->右子树的顺序访问二叉树` -> `先序遍历：（1）访问根节点；（2）采用先序递归遍历左子树；（3）采用先序递归遍历右子树； `
* `中序遍历：按照左子树->根节点->右子树的顺序访问 ` -> `中序遍历：（1）采用中序遍历左子树；（2）访问根节点；（3）采用中序遍历右子树 `
* `后序遍历 `  -> `后序遍历：（1）采用后序递归遍历左子树；（2）采用后序递归遍历右子树；（3）访问根节点； `

`二叉树的层次遍历思路，借助队列来实现。相当于广度优先搜索，使用队列（深度优先搜索的话，使用栈）`

#### 平衡查找树 

#### 递归树



**AVL树**: 最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。

**红黑树**: 平衡二叉树，广泛用在C++的STL中。如map和set都是用红黑树实现的。

**B/B+树: **用在磁盘文件组织 数据索引和数据库索引。

**Trie树(字典树): **用在统计和排序大量字符串，如自动机。

AVL树是平衡二叉搜索树的鼻祖，它的平衡度也最好，左右高度差可以保证在「-1，0，1」，基于它的平衡性，它的查询时间复杂度可以保证是O（log n）。但每个节点要额外保存一个平衡值，或者说是高度差。这种树是二叉树的经典应用，现在最主要是出现在教科书中。AVL的平衡算法比较麻烦，需要左右两种rotate交替使用，需要分四种情况，是数据结构课的最理想课后作业之一。

这里要重点强调，AVL插入新节点所需要的最大旋转次数是常数，再说一遍，是常数，不要为这个再来回复或者私信我了。这个也有证明，不需要一直旋转到根节点。

红黑树一样也是平衡二叉搜索树，也是工业界最主要使用的二叉搜索平衡树。但平衡度红黑树没AVL那么好。也就是说，如果从高度差来说，红黑树是大于AVL的，其实也就代表着它的实际查询时间(最坏情况)略逊于AVL的。数学证明红黑树的最大深度是 ![2\cdot log_{2} (n+1)](https://www.zhihu.com/equation?tex=2%5Ccdot+log_%7B2%7D+%28n%2B1%29)

 , 其实最差情况它从根到叶子的最长路可以是最短路的两倍，但也不是很差，所以它的查询时间复杂度也是O（log n）。从实现角度来说，保存红黑状态，每个节点只需要一位二进制，也就是一个bit（有些做法，可以把这个bit塞到其他地方，就可以不占用额外空间了）。可AVL每个节点需要额外存储一个平衡值（数）（按照评论中大神韦易笑的说法，avl的平衡值可以用两个bit来存储，然后塞到指针里，惊才绝艳的搞法。当然指针少两位会有什么问题，我就不多想了，你去找他，他有个很好的avl实现）。所以（这里不能用所以，因为谁知道真实原因是啥），一般工业界把红黑树作为一种更通用的平衡搜索数来用，Java用它来实现TreeMap, C++的std::set/map/multimap等等。

二叉平衡搜索树的问题在于每次插入和删除都有很大可能需要进行重新平衡，数据就要不停的搬来搬去，在内存中这问题不是特别大，可如果在磁盘中，这个开销可能就大了。

有兴趣的朋友还可以看看2-3-4 tree，它等价于红黑树，可以互相转换。它每个节点可以最多有四个孩子，重新平衡操作的次数稍稍少了一点点。以上这些树绝大多数应用都是作为内存中的数据结构。

B/B+ 树就是N叉（N-ary）平衡树了，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。

以上几种树都是有序的，如果你采用合适的算法遍历整个数，可以得到一个有序的列表。这也是为什么如果有数据库索引的情况下，你order by你索引的值，就会速度特别快，因为它并没有给你真的排序，只是遍历树而已。

Trie并不是平衡树，也不一定非要有序。它主要用于前缀匹配，比如字符串，比如说ip地址，如果字符串长度是固定或者说有限的，那么Trie的深度是可控制的，你可以得到很好的搜索效果，而且插入新数据后不用平衡。不过Trie不像B-tree通用性那么强，你需要针对你自己的实际应用来设计你自己的Trie，比如说你做个字典应用，是用26个字母，还是用unicode来前缀匹配？如果是ip地址搜索，是用二进制来前缀拼配，还是八进制来匹配？

C++ STL中的map就是用红黑树实现的。AVL树和红黑树都是二叉搜索树的变体，他们都是用于搜索。因为在这些书上搜索的时间复杂度都是O(h)，h为树高，而理想状况是h为![log](https://www.zhihu.com/equation?tex=log)n。所以构造的办法就是把二叉搜索树改造成AVL树或者红黑树，AVL树是严格维持平衡的，红黑树是黑平衡的。但是维持平衡又需要额外的操作，这也加大了数据结构的时间复杂度，所以红黑树可以看做是二叉搜索树和AVL树的一个折中，可以尽量维持树的平衡，又不用话过多的时间来维持数据结构的性质。

B树和B+树都是用来在磁盘上存储文件的数据结构。

### B-Tree介绍

B-Tree是一种多路搜索树（并不是二叉的）：
       1.定义任意非叶子结点最多只有M个儿子；且M>2；
       2.根结点的儿子数为[2, M]；
       3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
       4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
       5.非叶子结点的关键字个数=指向儿子的指针个数-1；
       6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
       7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
       8.所有叶子结点位于同一层；
       如：（M=3）

 

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG)
B-树的特性：
       1.关键字集合分布在整颗树中；
       2.任何一个关键字出现且只出现在一个结点中；
       3.搜索有可能在非叶子结点结束；
       4.其搜索性能等价于在关键字全集内做一次二分查找；
       5.自动层次控制；

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

### B+Tree介绍

B+树是B-树的变体，也是一种多路搜索树：

​       1.其定义基本与B-树同，除了：

​       2.非叶子结点的子树指针与关键字个数相同；

​       3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；

​       5.为所有叶子结点增加一个链指针；

​       6.所有关键字都在叶子结点出现；

​       如：（M=3）

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG)

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

​       B+的特性：

​       1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；

​       2.不可能在非叶子结点命中；

​       3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

​       4.更适合文件索引系统；

### 链表 

* `给一个单链表，判断其中是否有环的存在`
* `如果存在环，找出环的入口点`
* `如果存在环，求出环上节点的个数`
* `如果存在环，求出链表的长度`
* `如果存在环，求出环上距离任意一个节点最远的点（对面节点）`
* `（扩展）如何判断两个无环链表是否相交`
* `（扩展）如果相交，求出第一个相交的节点`

### 解决hash冲突

- `开放地址法`
- `链地址法 `

### 面试题

```
1、编程，找到第一个只出现一次的字符
2、编程，树的层序遍历
3、二叉树最远两个节点的距离（说思路）
4、动态地求中位数（说思路）
```

例子

kafka 二分查找日志

linux mmp avl树