###什么是CAS？

CAS（compare and swap）的缩写，中文翻译成比较并交换。

CAS 不通过JVM,直接利用java本地方 JNI（Java Native Interface为JAVA本地调用）,直接调用CPU 的cmpxchg（是汇编指令）指令。

利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法,实现原子操作。其它原子操作都是利用类似的特性完成的。

整个java.util.concurrent都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。

CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

####CAS应用

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

####CAS优点

确保对内存的读-改-写操作都是原子操作执行

####CAS缺点

CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作

####总结

1. **使用CAS在线程冲突严重时，会大幅降低程序性能；CAS只适合于线程冲突较少的情况使用**。
2. **synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS**。

### 8种原子操作

- `lock（锁定）`：`作用于主内存的变量，它把一个变量标识为一条线程独占的状态`
- `unlock（解锁）`：`作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定`
- `read（读取）`：`作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用`
- `load（载入）`：`作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中`
- `use（使用）`：`作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作`
- `assign（赋值）`：`作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作`
- `store（存储）`：`作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用`
- `write（写入）`：`作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中`

### 死锁

#### 饥饿 丢失信号 活锁